import cv2
import numpy as np
import matplotlib.pyplot as plt
import json
import os
import sys

# Helper Function to load descriptor data from JSON
def load_descriptor_data_from_json(json_path):
    """
    Loads keypoints and descriptors from a JSON file generated by SIFT, SURF, or ORB scripts.
    Returns: keypoints (list of cv2.KeyPoint), descriptors (np.ndarray), tool_name (str), original_image_path (str), descriptor_dim (int)
    """
    try:
        with open(json_path, 'r') as f:
            data = json.load(f)

        tool_name = data.get('tool', 'UNKNOWN').upper()

        keypoints_data = data['keypoints']
        descriptors_list = [kp_data['descriptor'] for kp_data in keypoints_data]

        keypoints = []
        for kp_data in keypoints_data:
            keypoints.append(cv2.KeyPoint(
                x=float(kp_data['x']),
                y=float(kp_data['y']),
                size=float(kp_data['size']),
                angle=float(kp_data['angle']),
                response=float(kp_data['response']),
                octave=int(kp_data['octave']),
                class_id=int(kp_data['class_id'])
            ))

        descriptor_dim = data.get("descriptor_dim", 0)
        if tool_name in ["SIFT", "SURF"]:
            descriptors = np.array(descriptors_list, dtype=np.float32)
            if descriptor_dim == 0: descriptor_dim = 128
        elif tool_name == "ORB":
            descriptors = np.array(descriptors_list, dtype=np.uint8)
            if descriptor_dim == 0: descriptor_dim = 32 # Default ORB is 32. Can be 64 if WTA_K > 2.
        else:
            raise ValueError(f"Unsupported descriptor tool type: '{tool_name}'. Descriptors cannot be loaded correctly.")

        original_image_path = data['image']['original_path']

        if not descriptors_list:
            print(f"[WARNING] No descriptors found in {os.path.basename(json_path)}. Returning empty descriptor array.")
            descriptors = np.empty((0, descriptor_dim), dtype=descriptors.dtype)

        return keypoints, descriptors, tool_name, original_image_path, descriptor_dim

    except FileNotFoundError:
        print(f"[ERROR] JSON file not found: {json_path}")
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"[ERROR] Error decoding JSON from: {json_path}. Check file format.")
        sys.exit(1)
    except KeyError as e:
        print(f"[ERROR] Missing required key '{e}' in JSON data from {os.path.basename(json_path)}. Please ensure JSON structure is correct.")
        sys.exit(1)
    except ValueError as e:
        print(f"[ERROR] Data conversion error in {os.path.basename(json_path)}: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[ERROR] An unexpected error occurred while loading features from {os.path.basename(json_path)}: {e}")
        sys.exit(1)


# --- Configuration (Hardcoded Parameters) ---
# PATHs ไปยังไฟล์ JSON ของคุณ
json_path_img1 = "/Users/pop/Desktop/project_n2n/sift_outputs/a1_sift_output.json" # เปลี่ยน Path ให้ถูกต้อง
json_path_img2 = "/Users/pop/Desktop/project_n2n/sift_outputs/a4_sift_output.json" # เปลี่ยน Path ให้ถูกต้อง
output_json_dir = "/Users/pop/Desktop/project_n2n/flann_outputs" # โฟลเดอร์สำหรับ output JSON

# FLANN Specific Parameters - Index (ปรับเปลี่ยนได้ตามความต้องการ)
# สำหรับ SIFT/SURF
FLANN_KD_TREES = 5
# สำหรับ ORB (ถ้าใช้ ORB, ค่า KD_TREES จะถูกละเลย)
FLANN_LSH_TABLES = 6
FLANN_LSH_KEY_SIZE = 12
FLANN_LSH_MULTI_PROBE_LEVEL = 1

# FLANN Specific Parameters - Search (ปรับเปลี่ยนได้ตามความต้องการ)
FLANN_SEARCH_CHECKS = 50 # ยิ่งเยอะ ยิ่งแม่นยำ แต่ช้าลง

# Filtering Parameter (ปรับเปลี่ยนได้ตามความต้องการ)
LOWES_RATIO_THRESHOLD = 0.75 # สำหรับ Lowe's Ratio Test

# Visualization Parameters (ปรับเปลี่ยนได้ตามความต้องการ)
MAX_IMAGE_DIM_FOR_DISPLAY = 1000 # Max width or height for display
NUM_MATCHES_TO_DRAW = 200 # จำนวน Match สูงสุดที่จะวาด

# --- Global Variables for Error Handling in Output ---
# Initialize with None or default values so they exist even if an early error occurs
kp1, des1, tool1, original_img_path1, dim1 = [], np.empty((0,)), "UNKNOWN", "N/A", 0
kp2, des2, tool2, original_img_path2, dim2 = [], np.empty((0,)), "UNKNOWN", "N/A", 0
good_matches = []
raw_matches_count = 0
flann_algorithm_str = "UNKNOWN"
knn_k_value = None # Can be 2 or None
index_params = None
search_params = None


# --- Start Main FLANN Matching Process ---
try:
    # --- Load Descriptor Data from JSON ---
    print(f"[INFO] Loading data from {os.path.basename(json_path_img1)}...")
    kp1, des1, tool1, original_img_path1, dim1 = load_descriptor_data_from_json(json_path_img1)
    print(f"[INFO] Image 1 ({tool1}): {len(kp1)} keypoints, Descriptors shape: {des1.shape}")

    print(f"[INFO] Loading data from {os.path.basename(json_path_img2)}...")
    kp2, des2, tool2, original_img_path2, dim2 = load_descriptor_data_from_json(json_path_img2)
    print(f"[INFO] Image 2 ({tool2}): {len(kp2)} keypoints, Descriptors shape: {des2.shape}")

    # --- Validate that both JSONs are from the same tool type (CRUCIAL for matching) ---
    if tool1 != tool2:
        print(f"\n[ERROR] Descriptor type mismatch! Image 1 is '{tool1}', Image 2 is '{tool2}'.")
        print("        FLANN requires both sets of descriptors to be generated by the SAME algorithm (e.g., SIFT-SIFT, ORB-ORB).")
        print("        Please ensure you run feature extraction with the same tool for both images.")
        sys.exit(1)

    # --- Check if enough keypoints exist for matching ---
    if len(kp1) == 0 or len(kp2) == 0 or des1.shape[0] == 0 or des2.shape[0] == 0:
        print("[ERROR] Not enough keypoints or descriptors to perform matching. Please check your input JSON files.")
        sys.exit(1)

    # --- Determine FLANN parameters based on the tool ---
    if tool1 in ["SIFT", "SURF"]:
        FLANN_INDEX_KD_TREE = 1
        index_params = dict(algorithm = FLANN_INDEX_KD_TREE, trees = FLANN_KD_TREES)
        search_params = dict(checks = FLANN_SEARCH_CHECKS)
        flann_algorithm_str = "KD_TREE"
        print(f"\n[INFO] Using FLANN with KD-Tree index (trees={FLANN_KD_TREES}) for '{tool1}' descriptors.")
    elif tool1 == "ORB":
        FLANN_INDEX_LSH = 6
        index_params = dict(algorithm = FLANN_INDEX_LSH,
                             table_number = FLANN_LSH_TABLES,
                             key_size = FLANN_LSH_KEY_SIZE,
                             multi_probe_level = FLANN_LSH_MULTI_PROBE_LEVEL)
        search_params = dict(checks = FLANN_SEARCH_CHECKS)
        flann_algorithm_str = "LSH"
        print(f"\n[INFO] Using FLANN with LSH index (tables={FLANN_LSH_TABLES}, key_size={FLANN_LSH_KEY_SIZE}, multi_probe_level={FLANN_LSH_MULTI_PROBE_LEVEL}) for '{tool1}' descriptors.")
    else:
        print(f"[ERROR] Unsupported descriptor tool type for FLANN: '{tool1}'. Cannot proceed with matching.")
        sys.exit(1)

    # --- Create FLANN Matcher ---
    flann_matcher = cv2.FlannBasedMatcher(index_params, search_params)
    print(f"[INFO] FLANN Matcher created with search checks: {FLANN_SEARCH_CHECKS}.")

    # --- Perform Matching (knnMatch with k=2 is typical for FLANN + Lowe's Ratio Test) ---
    knn_k_value = 2 # Fixed for Lowe's Ratio Test

    if des1.shape[0] < knn_k_value or des2.shape[0] < knn_k_value:
        print(f"[WARNING] Not enough descriptors for knnMatch(k={knn_k_value}). No matches will be found.")
        matches = []
    else:
        matches = flann_matcher.knnMatch(des1, des2, k=knn_k_value)
        raw_matches_count = len(matches)

        # Apply Lowe's Ratio Test
        print(f"[INFO] Applying Lowe's Ratio Test with threshold: {LOWES_RATIO_THRESHOLD}")

        for m, n in matches:
            if m.distance < LOWES_RATIO_THRESHOLD * n.distance:
                good_matches.append(m)
        good_matches = sorted(good_matches, key=lambda x: x.distance)

    print(f"[INFO] Total good matches found: {len(good_matches)}")
    print(f"[INFO] Total raw matches (before Lowe's Ratio Test): {raw_matches_count}")

    # --- Load Original Images for Visualization ---
    img1_orig = cv2.imread(original_img_path1, cv2.IMREAD_COLOR)
    img2_orig = cv2.imread(original_img_path2, cv2.IMREAD_COLOR)

    if img1_orig is None or img2_orig is None:
        print(f"[WARNING] Could not load original images for visualization (Image 1: {original_img_path1}, Image 2: {original_img_path2}). Skipping visualization.")
    else:
        # Resize images for better visualization if they are too large
        if img1_orig.shape[0] > MAX_IMAGE_DIM_FOR_DISPLAY or img1_orig.shape[1] > MAX_IMAGE_DIM_FOR_DISPLAY:
            scale_factor1 = MAX_IMAGE_DIM_FOR_DISPLAY / max(img1_orig.shape[0], img1_orig.shape[1])
            img1_orig = cv2.resize(img1_orig, (int(img1_orig.shape[1] * scale_factor1), int(img1_orig.shape[0] * scale_factor1)))

        if img2_orig.shape[0] > MAX_IMAGE_DIM_FOR_DISPLAY or img2_orig.shape[1] > MAX_IMAGE_DIM_FOR_DISPLAY:
            scale_factor2 = MAX_IMAGE_DIM_FOR_DISPLAY / max(img2_orig.shape[0], img2_orig.shape[1])
            img2_orig = cv2.resize(img2_orig, (int(img2_orig.shape[1] * scale_factor2), int(img2_orig.shape[0] * scale_factor2)))

        num_matches_to_draw = min(NUM_MATCHES_TO_DRAW, len(good_matches))
        print(f"[INFO] Drawing top {num_matches_to_draw} matches for visualization...")

        img_matches_vis = cv2.drawMatches(img1_orig, kp1, img2_orig, kp2,
                                         good_matches[:num_matches_to_draw], None,
                                         flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)

        plt.figure(figsize=(18, 10))
        plt.imshow(cv2.cvtColor(img_matches_vis, cv2.COLOR_BGR2RGB))
        plt.title(f"FLANN Matches ({tool1}) - {len(good_matches)} good matches")
        plt.axis('off')
        plt.show()

except (FileNotFoundError, json.JSONDecodeError, KeyError, ValueError, cv2.error) as e:
    print(f"[CRITICAL ERROR] Program terminated due to a data or OpenCV error: {e}", file=sys.stderr)
    sys.exit(1)
except Exception as e:
    print(f"[CRITICAL ERROR] An unexpected fatal error occurred during matching or data loading: {e}", file=sys.stderr)
    sys.exit(1)

# --- Outputting Matches Data (for N2N Node) ---
try:
    os.makedirs(output_json_dir, exist_ok=True)

    matches_output_data = []
    for m in good_matches:
        matches_output_data.append({
            "queryIdx": m.queryIdx,
            "trainIdx": m.trainIdx,
            "distance": round(m.distance, 4)
        })

    img1_base = os.path.basename(original_img_path1).split('.')[0]
    img2_base = os.path.basename(original_img_path2).split('.')[0]
    output_json_name = f"{img1_base}_vs_{img2_base}_{tool1.lower()}_flann_matches_detail.json"
    output_json_path = os.path.join(output_json_dir, output_json_name)

    # --- สร้าง Dictionary สำหรับ flann_parameters_used ให้แบนราบและเข้าใจง่ายขึ้น ---
    flann_parameters_for_json = {
        "index_algorithm": flann_algorithm_str,
        "search_checks": FLANN_SEARCH_CHECKS,
        "knn_k_value": knn_k_value,
        "lowes_ratio_threshold": LOWES_RATIO_THRESHOLD,
        # กำหนดค่าเริ่มต้นเป็น None สำหรับพารามิเตอร์ Index ที่อาจไม่ได้ใช้
        "kd_tree_trees": None,
        "lsh_table_number": None,
        "lsh_key_size": None,
        "lsh_multi_probe_level": None
    }

    if flann_algorithm_str == "KD_TREE":
        flann_parameters_for_json["kd_tree_trees"] = FLANN_KD_TREES
    elif flann_algorithm_str == "LSH":
        flann_parameters_for_json["lsh_table_number"] = FLANN_LSH_TABLES
        flann_parameters_for_json["lsh_key_size"] = FLANN_LSH_KEY_SIZE
        flann_parameters_for_json["lsh_multi_probe_level"] = FLANN_LSH_MULTI_PROBE_LEVEL
    # --- สิ้นสุดการสร้าง Dictionary ---

    with open(output_json_path, 'w') as f:
        json.dump({
            "matching_tool": "FLANNBasedMatcher",
            "tool_version": {
                "opencv": cv2.__version__,
                "python": sys.version.split()[0]
            },
            "flann_parameters_used": flann_parameters_for_json,
            "input_features_details": {
                "image1": {
                    "original_path": original_img_path1,
                    "file_name": os.path.basename(original_img_path1),
                    "feature_tool": tool1,
                    "num_keypoints": len(kp1),
                    "descriptor_shape": list(des1.shape)
                },
                "image2": {
                    "original_path": original_img_path2,
                    "file_name": os.path.basename(original_img_path2),
                    "feature_tool": tool2,
                    "num_keypoints": len(kp2),
                    "descriptor_shape": list(des2.shape)
                }
            },
            "matching_statistics": {
                "num_raw_matches": raw_matches_count,
                "num_good_matches": len(good_matches)
            },
            "matches": matches_output_data
        }, f, indent=4)
    print(f"\n[INFO] Detailed matching results saved to: {output_json_path}")
    print("[INFO] Example of first 5 good matches:")
    print(json.dumps(matches_output_data[:5], indent=4))
except IOError as e:
    print(f"[ERROR] Failed to save detailed matching JSON: {e}")
except Exception as e:
    print(f"[CRITICAL ERROR] An unexpected fatal error occurred during outputting matches: {e}", file=sys.stderr)
    sys.exit(1)

print("\n[INFO] FLANN Matcher process completed.")
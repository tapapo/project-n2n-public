import cv2
import numpy as np
import matplotlib.pyplot as plt
import json
import os
import sys

# --- Helper Function to load descriptor data from JSON ---
def load_descriptor_data_from_json(json_path):
    """
    Loads keypoints and descriptors from a JSON file generated by SIFT, SURF, or ORB scripts.
    Returns: keypoints (list of cv2.KeyPoint), descriptors (np.ndarray), tool_name (str), original_image_path (str)
    """
    try:
        with open(json_path, 'r') as f:
            data = json.load(f)

        tool_name = data.get('tool', 'UNKNOWN').upper()

        keypoints_data = data['keypoints']
        descriptors_list = [kp_data['descriptor'] for kp_data in keypoints_data]

        keypoints = []
        for kp_data in keypoints_data:
            keypoints.append(cv2.KeyPoint(
                x=float(kp_data['x']),
                y=float(kp_data['y']),
                size=float(kp_data['size']),
                angle=float(kp_data['angle']),
                response=float(kp_data['response']),
                octave=int(kp_data['octave']),
                class_id=int(kp_data['class_id'])
            ))

        # Determine descriptor dtype
        if tool_name in ["SIFT", "SURF"]:
            descriptors = np.array(descriptors_list, dtype=np.float32)
        elif tool_name == "ORB":
            descriptors = np.array(descriptors_list, dtype=np.uint8)
        else:
            # If tool name is UNKNOWN or unsupported, try to infer dtype or default to float32
            if descriptors_list and isinstance(descriptors_list[0][0], int): # Check if descriptor values look like ints (for ORB)
                 descriptors = np.array(descriptors_list, dtype=np.uint8)
                 if tool_name == "UNKNOWN": tool_name = "ORB (inferred)"
            else:
                 descriptors = np.array(descriptors_list, dtype=np.float32)
                 if tool_name == "UNKNOWN": tool_name = "SIFT/SURF (inferred)"
            print(f"[WARNING] Unrecognized tool '{data.get('tool', 'UNKNOWN')}', inferred descriptor type as {descriptors.dtype}. This might cause issues.")


        original_image_path = data['image']['original_path']

        if not keypoints_data: # Check if keypoints_data is empty, not descriptors_list
            print(f"[WARNING] No keypoints found in {os.path.basename(json_path)}. Returning empty arrays.")
            # Ensure empty descriptors array has correct shape if possible
            descriptor_dim = data.get("descriptor_dim", 0)
            if descriptor_dim == 0 and descriptors_list: # If dim not in JSON but list exists
                descriptor_dim = len(descriptors_list[0])
            descriptors = np.empty((0, descriptor_dim), dtype=descriptors.dtype if descriptors.dtype else np.float32)


        return keypoints, descriptors, tool_name, original_image_path

    except FileNotFoundError:
        print(f"[ERROR] JSON file not found: {json_path}")
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"[ERROR] Error decoding JSON from: {json_path}. Check file format.")
        sys.exit(1)
    except KeyError as e:
        print(f"[ERROR] Missing required key '{e}' in JSON data from {os.path.basename(json_path)}. Please ensure JSON structure is correct.")
        sys.exit(1)
    except ValueError as e:
        print(f"[ERROR] Data conversion error in {os.path.basename(json_path)}: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[ERROR] An unexpected error occurred while loading features from {os.path.basename(json_path)}: {e}")
        sys.exit(1)

# --- Helper Function to save Homography output to JSON ---
def save_homography_output_to_json(output_path, H, inlier_mask,
                                  image1_path, image2_path, num_good_matches, num_inliers,
                                  ransac_threshold, max_iters, confidence):
    """
    Saves the computed Homography matrix and inlier mask to a JSON file.
    """
    # Ensure H is handled even if None
    H_list = H.tolist() if H is not None else None

    # Convert num_inliers to standard Python int
    num_inliers_python = int(num_inliers) if isinstance(num_inliers, np.integer) else num_inliers

    # Convert inlier_mask to a standard Python list, handling None case
    inlier_mask_list = []
    if inlier_mask is not None:
        # Convert the numpy array elements to Python integers as well
        # Some numpy versions might return uint8 or bool for mask, ensure it's int
        inlier_mask_list = inlier_mask.flatten().astype(int).tolist()


    json_data = {
        "alignment_tool": "Homography_RANSAC",
        "tool_version": {
            "opencv": cv2.__version__,
            "python": sys.version.split()[0]
        },
        "input_images": {
            "image1_path": image1_path,
            "image2_path": image2_path
        },
        "homography_parameters_used": {
            "ransac_reproj_threshold": ransac_threshold,
            "max_iterations": max_iters,
            "confidence_level": confidence
        },
        "matching_statistics_input": {
            "total_good_matches_before_ransac": num_good_matches
        },
        "homography_results": {
            "homography_matrix": H_list, # Use the converted H_list
            "num_inliers": num_inliers_python, # Use the converted num_inliers
            "inlier_mask": inlier_mask_list # Use the converted inlier_mask
        }
    }
    try:
        with open(output_path, 'w') as f:
            json.dump(json_data, f, indent=4)
        print(f"[INFO] Homography results saved to: {output_path}")
    except IOError as e:
        print(f"[ERROR] Failed to save Homography JSON: {e}")

# --- Configuration ---
# PATHs to your JSON files
# This is the path to the output of BFMatcher or FLANN
matching_json_path = "/Users/pop/Desktop/project_n2n/bfmatcher_outputs/BallA_grayscale_vs_BallB_grayscale_sift_bf_matches_detail.json" # <--- IMPORTANT: Change this path

# Folder for Homography output
output_dir = "/Users/pop/Desktop/project_n2n/homography_outputs"
os.makedirs(output_dir, exist_ok=True)

# Homography Parameters (can be tuned)
RANSAC_REPROJ_THRESHOLD = 5.0 # pixels, common values are 1.0-10.0
MAX_RANSAC_ITERS = 2000       # Maximum number of RANSAC iterations
CONFIDENCE = 0.995            # Confidence level for RANSAC

# --- Main Process ---
print("--- Starting Homography Estimation with RANSAC ---")

# 1. Load Matching Data
try:
    with open(matching_json_path, 'r') as f:
        matching_data = json.load(f)
    print(f"[INFO] Loaded matching data from: {os.path.basename(matching_json_path)}")

    # Get original image paths from the matching JSON
    img1_original_path = matching_data['input_features_details']['image1']['original_path']
    img2_original_path = matching_data['input_features_details']['image2']['original_path']
    
    # Get original feature tool and build path to feature JSON (assuming standard naming)
    feature_tool_img1 = matching_data['input_features_details']['image1']['feature_tool'].lower()
    feature_tool_img2 = matching_data['input_features_details']['image2']['feature_tool'].lower()

    # Reconstruct feature JSON paths. Adjust this logic if your feature JSONs are not in the same directory as matching JSON.
    # This assumes feature outputs are in folders like 'sift_outputs', 'surf_outputs', 'orb_output'
    base_output_dir = os.path.dirname(os.path.dirname(matching_json_path)) # Assumes project_n2n is the base
    
    img1_feature_json_path = os.path.join(
        base_output_dir, f"{feature_tool_img1}_outputs",
        os.path.basename(img1_original_path).replace(os.path.splitext(os.path.basename(img1_original_path))[1], f'_{feature_tool_img1}_output.json')
    )
    img2_feature_json_path = os.path.join(
        base_output_dir, f"{feature_tool_img2}_outputs",
        os.path.basename(img2_original_path).replace(os.path.splitext(os.path.basename(img2_original_path))[1], f'_{feature_tool_img2}_output.json')
    )
    
    # Debugging paths
    print(f"[DEBUG] Predicted feature JSON path for Image 1: {img1_feature_json_path}")
    print(f"[DEBUG] Predicted feature JSON path for Image 2: {img2_feature_json_path}")


    good_matches_data = matching_data['matches']
    num_good_matches_input = len(good_matches_data)
    print(f"[INFO] Found {num_good_matches_input} good matches from input JSON.")

except (FileNotFoundError, json.JSONDecodeError, KeyError) as e:
    print(f"[ERROR] Failed to load or parse matching JSON: {e}")
    sys.exit(1)
except Exception as e:
    print(f"[ERROR] An unexpected error occurred during matching data loading: {e}")
    sys.exit(1)


# 2. Load Keypoints for both images using their respective feature JSONs
try:
    kp1, des1, tool1_name, _ = load_descriptor_data_from_json(img1_feature_json_path)
    kp2, des2, tool2_name, _ = load_descriptor_data_from_json(img2_feature_json_path)
except SystemExit: # Catch SystemExit from helper function if file not found
    sys.exit(1)


if len(kp1) == 0 or len(kp2) == 0:
    print("[ERROR] No keypoints loaded for one or both images. Cannot proceed with Homography.")
    sys.exit(1)

# Prepare lists for source and destination points
# Ensure that good_matches_data has enough entries to prevent IndexError
if len(good_matches_data) == 0:
    print("[ERROR] No good matches found. Cannot compute Homography.")
    sys.exit(1)

pts_src = np.float32([kp1[m['queryIdx']].pt for m in good_matches_data]).reshape(-1, 1, 2)
pts_dst = np.float32([kp2[m['trainIdx']].pt for m in good_matches_data]).reshape(-1, 1, 2)

if pts_src.shape[0] < 4: # Need at least 4 points for Homography
    print(f"[ERROR] Not enough (minimum 4) good matches ({pts_src.shape[0]} found) to compute Homography. Exiting.")
    sys.exit(1)

# 3. Compute Homography Matrix using RANSAC
print(f"\n[INFO] Computing Homography using RANSAC with threshold: {RANSAC_REPROJ_THRESHOLD} pixels...")
H, mask = cv2.findHomography(
    pts_src,
    pts_dst,
    cv2.RANSAC,
    RANSAC_REPROJ_THRESHOLD,
    maxIters=MAX_RANSAC_ITERS,
    confidence=CONFIDENCE
)

num_inliers = 0
if mask is not None:
    num_inliers = np.sum(mask)
    print(f"[INFO] Homography computed. Found {num_inliers} inliers out of {num_good_matches_input} good matches.")
    if H is None:
        print("[WARNING] Homography matrix is None. This can happen if RANSAC fails to find a good model.")
    elif num_inliers == 0:
        print("[WARNING] No inliers found by RANSAC. Homography might be unreliable.")
else:
    print("[WARNING] Mask is None. This indicates an issue with Homography computation.")


# 4. Save Results to JSON
img1_base = os.path.basename(img1_original_path).split('.')[0]
img2_base = os.path.basename(img2_original_path).split('.')[0]
output_json_name = f"{img1_base}_vs_{img2_base}_homography_output.json"
output_json_path = os.path.join(output_dir, output_json_name)

save_homography_output_to_json(
    output_json_path, H, mask,
    img1_original_path, img2_original_path, num_good_matches_input, num_inliers,
    RANSAC_REPROJ_THRESHOLD, MAX_RANSAC_ITERS, CONFIDENCE
)


# 5. Visualization (Optional - Transform Image 1 onto Image 2's perspective)
print("\n[INFO] Preparing visualization...")
try:
    img1_orig_color = cv2.imread(img1_original_path, cv2.IMREAD_COLOR)
    img2_orig_color = cv2.imread(img2_original_path, cv2.IMREAD_COLOR)

    if img1_orig_color is None:
        raise FileNotFoundError(f"Image 1 not found: {img1_original_path}")
    if img2_orig_color is None:
        raise FileNotFoundError(f"Image 2 not found: {img2_original_path}")

    # Resize images for better visualization if they are too large
    max_display_dim = 1000
    if img1_orig_color.shape[0] > max_display_dim or img1_orig_color.shape[1] > max_display_dim:
        scale_factor = max_display_dim / max(img1_orig_color.shape[:2])
        img1_orig_color = cv2.resize(img1_orig_color, None, fx=scale_factor, fy=scale_factor)
    if img2_orig_color.shape[0] > max_display_dim or img2_orig_color.shape[1] > max_display_dim:
        scale_factor = max_display_dim / max(img2_orig_color.shape[:2])
        img2_orig_color = cv2.resize(img2_orig_color, None, fx=scale_factor, fy=scale_factor)


    if H is not None and num_inliers > 0:
        # Draw only inlier matches
        inlier_matches = []
        for i, m_data in enumerate(good_matches_data):
            if mask[i] == 1:
                # Recreate DMatch object for drawing (using queryIdx, trainIdx from good_matches_data)
                dm = cv2.DMatch(m_data['queryIdx'], m_data['trainIdx'], m_data['distance'])
                inlier_matches.append(dm)
        
        # Draw the inlier matches
        # Limit matches drawn for performance/clarity if too many
        num_matches_to_draw_vis = min(200, len(inlier_matches))
        print(f"[INFO] Drawing top {num_matches_to_draw_vis} inlier matches for visualization...")

        img_inlier_matches_vis = cv2.drawMatches(img1_orig_color, kp1, img2_orig_color, kp2,
                                                 inlier_matches[:num_matches_to_draw_vis], None,
                                                 flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS | cv2.DrawMatchesFlags_DRAW_RICH_KEYPOINTS)

        # Warp image 1 to align with image 2's perspective
        h_target, w_target = img2_orig_color.shape[:2]
        img1_warped = cv2.warpPerspective(img1_orig_color, H, (w_target, h_target))

        # Combine original image 2 with the warped image 1 using alpha blending
        alpha = 0.5 # Transparency for blending (0.0 = only img2_orig, 1.0 = only img1_warped)
        blended_output = cv2.addWeighted(img1_warped, alpha, img2_orig_color, 1 - alpha, 0)

        plt.figure(figsize=(20, 10))

        plt.subplot(1, 2, 1)
        plt.imshow(cv2.cvtColor(img_inlier_matches_vis, cv2.COLOR_BGR2RGB))
        plt.title(f"Inlier Matches ({num_inliers} points)")
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.imshow(cv2.cvtColor(blended_output, cv2.COLOR_BGR2RGB))
        plt.title(f"Image 1 Warped onto Image 2 (Blended, alpha={alpha})")
        plt.axis('off')

        plt.tight_layout()
        plt.show()

    else:
        print("[WARNING] Skipping visualization: Homography matrix is None or no inliers found.")

except FileNotFoundError as e:
    print(f"[ERROR] Visualization skipped due to missing image file: {e}")
except Exception as e:
    print(f"[ERROR] An unexpected error occurred during visualization: {e}")

print("\n--- Homography Estimation with RANSAC Completed ---")